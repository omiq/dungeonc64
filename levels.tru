Unit levels;
var
	
	// Variables
	r, row, column, height, width, b: byte;
	current_level: integer=0;
	t_x, t_y, tile_no: byte;	
	temp_s, temp_d, screen, dest, ch_index: pointer;
	this_row: integer;
	tiles_across:byte;
	detected_screen_width: byte; // built-in doesn't work for pet
	this_string: string=("                              ");
	
	// Buffer array lookup table for electron
	b_tab: array[18] of integer;
	
	// screen buffer
	screen_buffer: array[1000] of byte;


	@ifndef ATARI800	
		tiles: incbin("levels/map - Tiles.bin");	
	@endif

	@ifdef ATARI800	
		tiles: incbin("levels/Atari Tiles.bin");	
	@endif


	
	level: incbin("levels/map.bin");	
	level_p: pointer;


	
@ifndef X86	
	procedure draw_tile(t_x, t_y, tile_no: global byte);
	begin
	
		// Source
		temp_s:=#tiles+(tile_no*9);
	
		// Dest
		dest:=#screen_buffer+((t_y*3)*detected_screen_width)+(t_x*3);
		MemCpyFast(temp_s, 0, dest,3);

		temp_s:=temp_s+3;
		dest:=dest+detected_screen_width;		
		MemCpyFast(temp_s, 0, dest,3);
		
		dest:=dest+detected_screen_width;	
		temp_s:=temp_s+3;	
		MemCpyFast(temp_s, 0, dest,3);

	end;
@endif

@ifdef X86	
	procedure draw_tile(t_x, t_y, tile_no: global byte);
	begin
	
		// Source
		temp_s:=#tiles+(tile_no*9);
	
		// Dest
		dest:=#screen_buffer+((t_y*3)*detected_screen_width)+(t_x*3);
		MemCpy8(temp_s, dest,3);

		temp_s:=temp_s+3;
		dest:=dest+detected_screen_width;		
		MemCpy8(temp_s, dest,3);
		
		dest:=dest+detected_screen_width;	
		temp_s:=temp_s+3;	
		MemCpy8(temp_s, dest,3);

	end;
@endif
	

	

	procedure draw_level();
	var
		
	begin

		// set to draw tiles
		dest:=#screen_buffer;	
		level_p:=#level+(current_level*60);

		
		for t_y:=0 to 6 do
		begin
			for t_x:=0 to tiles_across do
			begin
				tile_no:=level_p[(t_y*10)+t_x];
				draw_tile(t_x,t_y,tile_no);
			end;			
		end;
	
	
	end;
	

	

@ifndef BBCM
	procedure refresh_screen();
	begin
		
		temp_s:=#screen_buffer;
		
		// Need rows at the bottom 
		// for text output
		for r:=0 to 18 do
		begin
			dest:=txt::ytab[r];
			@ifndef X86	
			MemCpyFast(temp_s, 0, dest, detected_screen_width);
			@endif
			@ifdef X86	
			MemCpy16(temp_s, dest, detected_screen_width);
			@endif
			temp_s:=temp_s+detected_screen_width;
		end;		

	end;
@endif

@ifdef BBCM

	procedure electron_row(r:global byte) inline;
	begin
		temp_s:=b_tab[r];
		memcpyfast(#temp_s,0,#this_string,30);
		txt::print_string(#this_string,true);	
	end;


	procedure refresh_screen();
	var

	begin
		
		temp_s:=#screen_buffer;
		
		// Need rows at the bottom 
		// for text output
		if(txt::current_bbc()>0) then
		begin


			// BBC
			for r:=0 to 18 do
			begin
				dest:=txt::ytab[r];
				MemCpyFast(temp_s, 0, dest, detected_screen_width);
				temp_s:=temp_s+detected_screen_width;
			end;		
		end
		else
		begin
			
			
			// Electron
			txt::move_to(0,0);
			electron_row(0);
			electron_row(1);
			electron_row(2);
			electron_row(3);
			electron_row(4);
			electron_row(5);
			electron_row(6);
			electron_row(7);
			electron_row(8);
			electron_row(9);
			electron_row(10);
			electron_row(11);
			electron_row(12);
			electron_row(13);
			electron_row(14);
			electron_row(15);
			electron_row(16);
			electron_row(17);

		end;

	end;
@endif

		// Put a char in the screen buffer
	function get_buffer(buf_x, buf_y: byte):byte;
	begin
		
		ch_index:=#screen_buffer+(buf_y*detected_screen_width)+buf_x;
		get_buffer:=ch_index[0];
		
	end;


	// Put a char in the screen buffer
	procedure plot_buffer(plot_x, plot_y: byte, plot_ch: byte);
	begin
		
		ch_index:=#screen_buffer+(plot_y*detected_screen_width)+plot_x;
		ch_index[0]:=plot_ch;
		
	end;



end.